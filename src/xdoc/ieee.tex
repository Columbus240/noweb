\documentstyle[11pt,noweb]{article}
\title{Literate Programming Tools Need Not Be Complex}
\author{Norman Ramsey\\Department of Computer Science, Princeton University\\
35 Olden Street, Princeton, New Jersey 08544}
%\reportno{CS-TR-351-91}
\date{October 1991}
\setcounter{secnumdepth}{0}

\makeatletter
\def\refno#1{\nocite{#1}\@ifundefined
       {b@#1}{{\bf ?}\@warning
       {Reference number `#1' on page \thepage \space undefined}}%
{\hbox{\csname b@#1\endcsname}}}
\makeatother

\def\remark#1{\marginpar{\raggedright\hbadness=10000\footnotesize\it #1}}
% \def\remark#1{\relax}

\begin{document}

\maketitle

\begin{abstract}
When it was introduced, literate programming meant {\tt WEB}.
Desire to use {\tt WEB} with languages other than Pascal led to the
implementation of many versions.
{\tt WEB} is complex, and the difficulty of using {\tt WEB} creates
an artificial barrier to
experimentation with literate programming.
 {\tt noweb} provides much of the functionality of
{\tt WEB}, with a fraction of the complexity.
{\tt noweb} is independent of the target programming language, and its
formatter-dependent part is a 40-line shell script. 
{\tt noweb} is extensible, because it uses two
representations of programs: one easily manipulated by authors and one
easily manipulated by tools.
I give examples of the use of {\tt noweb} and I mention
 applications that have been written
using {\tt noweb} with different programming languages.
\end{abstract}

\begin{center}\small
{\bf Key words:}
literate~programming, readability, programming~environments
\end{center}

\section{Introduction}
When literate programming was
introduced, it was synonymous with {\tt WEB}, a tool
for writing literate Pascal programs~\cite{knuth:literate}.
The idea attracted attention; several examples of literate
programs were published, and a special forum was created to discuss literate
programming~\cite{denning:announcing,gries:pearls,bentley:lp1,bentley:lp2}.
{\tt WEB} was  adapted to programming languages other than
Pascal~\cite{guntermann:cweb,levy:cweb,ramsey:building,sewell:mangle,thimbleby:cweb}.
%
With experience, many {\tt WEB} users became dissatisfied~\cite{ramsey:literate}. 
Some found {\tt WEB} not worth the trouble, as did
one author of the program appearing in Appendix~C
of Reference~\refno{sewell:weaving}.
Others built their own systems for literate
 programming~\cite{hamilton:expanding,cvw:loom}. 
The literate programming forum was dropped, on the grounds that
literate programming had become the province of those who could build
their own tools~\cite{cvw:assessment}.

{\tt WEB}  programmers
 interleave source code and descriptive text in a single document.
When using {\tt WEB}, a programmer divides the source code into
{\em modules}.
Each module has a documentation part and a code part, and
modules may be written in any order.
The programmer is encouraged to choose an order that helps explain the program.
The code parts are like macro definitions;  they have names, and they contain
both code and references to other modules.
A {\tt WEB} file represents a single program;
{\tt TANGLE}  extracts that program from the {\tt WEB} source. 
One special module has a code part with no name, and {\tt TANGLE}
expands the code part of that module to extract the program.
{\tt WEAVE} converts {\tt WEB} source to
{\TeX} input, from which {\TeX} can produce high-quality typeset
documentation of the program.


{\tt WEB} is a complex tool.
In addition to enabling programmers to present pieces of a program in
any order, it expands three kinds of macros, prettyprints code,
evaluates some constant expressions,
provides an integer representation for string literals, and implements
a simple form of version control.
The manual for the original version documents 27 ``control sequences''~\cite{knuth:web}.
The versions for languages other than Pascal offer slightly different
functions and different sets of control sequences.
Significant effort is required to make {\tt WEB} usable with a new
programming language, even when using a tool designed for that
purpose~\cite{ramsey:building}. 

{\tt WEB}'s shortcomings make it difficult to explore the {\em idea}
of literate programming; too much effort is required to master the
{\em tool}.
I designed a new tool that is both
simple and independent of the target programming language.
{\tt noweb} is designed 
around one idea: writing named chunks of code in any order, with
interleaved documentation. 
Like {\tt WEB}, and like all literate programming tools, it can
be used to write a program in pieces and to present those pieces in
an order that helps explain the program.
{\tt noweb} makes two contributions.
It provides functionality
comparable to that of {\tt WEB}, without the complexity, and it is extensible.
It achieves its extensibility
 by using two representations of literate programs:
 one that is simple for authors to read and edit, and one that 
is simple for programs to read and transform.

\section{{\tt noweb}} % , a minimal literate programming system}
A {\tt noweb} file contains program source code interleaved with documentation.
When {\tt notangle} is given a {\tt noweb} file, it writes the program
 on standard output. 
When {\tt noweave} is given a {\tt noweb} file, it reads the {\tt
noweb} source and produces, on standard output, {\TeX} source for
typeset documentation.
Figure~\ref{transforms} shows how to use {\tt notangle} and {\tt
noweave} to produce code and documentation for a C~program contained
in the {\tt noweb} file {\tt foo.nw}.

\begin{figure}
\footnotesize
\setlength{\unitlength}{2pt}
\begin{picture}(170,80)(0,-40)
\tt
\put(20,12.5){\makebox(0,0)[l]{\ \tt notangle foo.nw > foo.c}}
\put(20,-12.5){\makebox(0,0)[l]{\ \tt noweave foo.nw > foo.tex}}

\put(0,-5){\framebox(30,10){foo.nw}}
\put(15,5){\vector(1,2){7.5}}
\put(10,20){\framebox(30,10){foo.c}}
\put(15,-5){\vector(1,-2){7.5}}
\put(10,-30){\framebox(30,10){foo.tex}}

\put(40,-25){\vector(1,0){35}}
\put(57.5,-23.5){\makebox(0,0)[b]{tex foo}}
\put(75,-30){\framebox(30,10){foo.dvi}}
\put(105,-25){\vector(1,0){35}}
\put(122.5,-23.5){\makebox(0,0)[b]{\strut \tt dvi foo}}
                        % \shortstack{\strut dvi\\\strut \rm driver}}}
\put(140,-25){\makebox(0,0)[l]{\rm\strut \ Typeset documentation for
{\tt foo}}}

\put(40,25){\vector(1,0){35}}
\put(57.5,26.5){\makebox(0,0)[b]{cc -c foo.c}}
\put(75,20){\framebox(30,10){foo.o}}
\put(105,25){\vector(1,0){35}}
\put(122.5,26.5){\makebox(0,0)[b]{ld foo.o {\ldots}}}
\put(140,25){\makebox(0,0)[l]{\rm\strut \ Executable \tt a.out}}



\end{picture}

\caption{Using {\tt noweb} to build code and documentation}
\label{transforms}
\end{figure}

A {\tt noweb} file is a sequence of {\em chunks}, which may appear in any order.
A chunk may contain code or documentation.
Documentation chunks begin with a line that starts with an at sign ({\tt @})
followed by a space or newline.
They have no names.
Code chunks begin with
\begin{quote} 
\tt <<{\it chunk name}>>=
\end{quote} 
on a line by itself.
The double left angle bracket ({\tt <<}) must be in the first column.
Chunks are terminated by the beginning of another chunk, or by end of file.
If the first line in the file does not mark the beginning of a
chunk, it is assumed to be the first line of a documentation chunk.

Documentation chunks contain text that is ignored by {\tt notangle}
and copied verbatim to standard output by
{\tt noweave} (except for quoted code).   
{\tt Noweave} can work with {\LaTeX}~\cite{lamport:latex}, or it can
insert a reference to 
a {\TeX} macro package, supplied with {\tt noweb}, that defines
commands like \verb+\chapter+ and \verb+\section+.

Code chunks contain program source code and references to other code
chunks.  
Several code chunks may have the same name; {\tt notangle}
concatenates their definitions to produce a single chunk, just as
 {\tt TANGLE} does.
Code chunk definitions are like macro definitions;
{\tt notangle} extracts a program by expanding one chunk (by default
the chunk named \verb+<<*>>+).
The definition of that chunk contains references to other chunks,
which are themselves expanded, and so on.
{\tt notangle}'s output is readable; it preserves the indentation of expanded
chunks with respect to the chunks in which they appear.

Code may be quoted within documentation chunks by placing double
square brackets around it ({\tt [[...]]}). 
These double square brackets are ignored by {\tt notangle,} but they
are used by {\tt noweave} to give code special typographic
treatment.

If the double left or right angle % or square 
bracket is to be used in code or documentation,
not as part of a chunk name, it must be preceded by an at sign
(e.g.~``{\tt @<<}''). 

Figure~\ref{sample-input} shows a fragment of a {\tt noweb} program
that computes prime numbers.
The program is derived from the example used in
Reference~\refno{knuth:literate}, and Figure~\ref{sample-input} should
be compared with Figure~2b of Reference~\refno{knuth:literate}.
Figure~\ref{noweave-output} shows the program after processing by {\tt
noweave} and {\LaTeX}.
Figure~\ref{notangle-output} shows the beginning of the program as
extracted by {\tt notangle}.

\begin{figure}
\begin{verbatim}
@ This program has no input, because we want to keep it
simple.  The result of the program will be to produce a
list of the first thousand prime numbers, and this list
will appear on the [[output]] file.

Since there is no input, we declare the value [[m = 1000]]
as a compile-time constant.  The program itself is capable
of generating the first [[m]] prime numbers for any
positive [[m]], as long as the computer's finite
limitations are not exceeded.
<<program to print the first thousand prime numbers>>=
program print_primes(output);
  const m = 1000;
        <<other constants of the program>>
  var <<variables of the program>>
    begin <<print the first [[m]] prime numbers>>
    end.
\end{verbatim} 
\caption{Sample {\tt noweb} input, from prime number program}
\label{sample-input}
\end{figure}



\begin{figure}
\begin{quote} 
\begindocs{4}

This program has no input, because we want to keep it simple.
The result of the program will be to produce a list of the first
thousand prime numbers, and this list will appear on the \code{}output\edoc{}
file.

Since there is no input, we declare the value \code{}m = 1000\edoc{} as a
compile-time constant.
The program itself is capable of generating the first \code{}m\edoc{} prime
numbers for any positive \code{}m\edoc{}, as long as the computer's finite
limitations are not exceeded.
\enddocs
\begincode{5}
\moddef{program to print the first thousand prime numbers}\endmoddef
program print_primes(output);
  const m = 1000;
        \LA{}other constants of the program\RA{}
  var \LA{}variables of the program\RA{}
    begin \LA{}print the first \code{}m\edoc{} prime numbers\RA{}
    end.
\endcode
\end{quote} 
\caption{Output produced by {\tt noweave} and {\LaTeX} from Figure~\protect\ref{sample-input}}
\label{noweave-output}
\end{figure}

\section{Using {\tt noweb}}% experience with noweb?

Experimenting with \verb+noweb+ is easy.
{\tt noweb} has little syntax: definition and use of code chunks, marking of
documentation chunks, quoting of code, and quoting of brackets.
The manual fits on two pages.
%% Most programs can be converted to \verb+noweb+ programs by making the
%% first line \verb+<<*>>=+.
\verb+noweb+ is independent of the target programming
language, and its formatter-dependent part is a 40-line script.

{\tt WEB}'s  original {\tt TANGLE} removed white space and folded
lines to fill each line with tokens,
making its output unreadable~\cite[Figure~3]{knuth:literate}.
Later adaptations preserved line breaks but removed other white space.
Those who experimented with {\tt WEB} but didn't like it had to
edit {\tt TANGLE}'s output by hand in order to recover a readable, compilable
program.
\verb+noweb+ makes it easy to abandon an experiment, because 
\verb+notangle+'s output is readable.
Because \verb+notangle+ preserves indentation, it can be used with
languages like Miranda~\cite{turner:miranda} and
Haskell~\cite{hudak:report}, in which indentation is significant.
 {\tt TANGLE} cannot.

% \begin{figure}
% \begin{center}
% \noindent
% \begin{minipage}[t]{2.5in}
% \begin{quote}\tt\obeyspaces
% <<*>>=\\
% one <<two>> <<three>>\\
% <<two>>=\\
% first of two\\
% second of two\\
% third of two\\
% <<three>>=\\
% first of three\\
% \mbox{}\ second of three\\
% \mbox{}\ \ third of three
% \end{quote}
% \end{minipage}\hfil
% \begin{minipage}[t]{2.5in}
% \begin{quote}\tt\obeyspaces
% one\ first\ of\ two\\
% \mbox{}\ \ \ \ second\ of\ two\\
% \mbox{}\ \ \ \ third\ of\ \rlap{two\ first\ of\ three}\\
% \mbox{}\rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ second\ of\ three}\\
% \mbox{}\rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ \ third\ of\ three}
% \end{quote}
% \end{minipage}
% \end{center}
% \leavevmode\noindent
% \hbox to \hsize{\hbox to 2.5in{\hss Input\hss}\hss\hbox to 2.5in{\hss Output\hss}}
% \medskip
% \begin{quote} 
% Those who dislike literate programming can use {\tt notangle} once,
% discard the original input, and work only with the output.
% Preserving indentation makes the output readable.
% It is also useful for programmers working in languages with no support
% for preprocessors, or where newlines or indentation are significant.
% \end{quote} 
% \caption{{\tt notangle} preserving indentation}
% \label{indentation}
% \end{figure}

\begin{figure}
\begin{verbatim}
program print_primes(output);
  const m = 1000;
        rr = 50;
        cc = 4;
        ww = 10;
        ord_max = 30;  { p_ord_max squared must exceed p_m }
  var p: array [1..m] of integer;
            { the first m prime numbers, in increasing order }
      page_number: integer;
\end{verbatim}
\unskip
\hbox{\hskip2em\tt\vdots}
\caption{Part of primes program as written by {\tt notangle}}
\label{notangle-output}
\end{figure}


% \begin{figure}
% \begin{verbatim}
% #line 41 "primes.nw"
% program print_primes(output);
%   const m = 1000;
% 
% #line 81 "primes.nw"
% rr = 50;
% cc = 4;
% ww = 10;
% #line 141 "primes.nw"
% ord_max = 30;  { p_ord_max squared must exceed p_m }
% #line 43 "primes.nw"
% 
%   var
% \end{verbatim}
% \hbox{\hskip2em\vdots}
% \caption{Part of primes program as written by {\tt notangle -L}}
% \label{notangle-L-output}
% \end{figure}


On a large project, it is essential that compilers and other tools be
able to refer to locations in the \verb+noweb+ source, even though
they work with \verb+notangle+'s output~\cite{ramsey:literate}.
Giving \verb+notangle+ the  \verb+-L+ option makes it emit pragmas
that inform compilers of the placement of lines
in the \verb+noweb+ source.
It also preserves the columns in which
tokens appear.
% Figure~\ref{renumbering} shows an example using the line number
% pragmas recognized by the C~preprocessor.
% The empty line in the figure contains the blank that appeared on
% line~2 between ``\verb+<<two>>+'' and ``\verb+<<three>>+.''



% \begin{figure}
% \begin{center}
% \noindent
% \begin{minipage}[t]{2.5in}
% \begin{quote}\tt\obeyspaces
% <<*>>=\\
% one <<two>> <<three>>\\
% <<two>>=\\
% first of two\\
% second of two\\
% third of two\\
% <<three>>=\\
% first of three\\
% \mbox{}\ second of three\\
% \mbox{}\ \ third of three
% \end{quote}
% \end{minipage}\hfil
% \begin{minipage}[t]{2.5in}
% \begin{quote}\tt
% \#line 2 "test.nw"\\
% one\\
% \#line 4 "test.nw"\\
% first of two\\
% second of two\\
% third of two\\
% \#line 2 "test.nw"\\
% \mbox{\hskip 1em}\\
% \#line 8 "test.nw"\\
% first of three\\
% \mbox{}\ second of three\\
% \mbox{}\ \ third of three
% \end{quote}
% \end{minipage}
% \end{center}
% \leavevmode\noindent
% \hbox to \hsize{\hbox to 2.5in{\hss Input\hss}\hss\hbox to 2.5in{\hss Output\hss}}
% \begin{quote} 
% Those who like literate programming can keep (and edit) the original
% source, giving {\tt notangle}'s output to their compilers.
% Preserving position information makes compiler messages refer to
% locations in the original source.
% \end{quote} 
% \caption{{\tt notangle} preserving position information}
% \label{renumbering}
% \end{figure}


{\tt WEB} files map one to one with to both programs and documents.
The mapping of \verb+noweb+ files to programs is many to many; the
mapping of files to documents is many to one.
Source files are combined by listing their names on \verb+notangle+'s
or \verb+noweave+'s command line.
Different programs may be extracted by specifying the names
of different root chunks, using \verb+notangle+'s \verb+-R+ command-line
option.

%\clearpage % fixes bad break
The simplest example of a one-to-many mapping of programs is that of putting
C~header and source in a single {\tt noweb} file.
Here are example rules for {\tt make}~\cite{feldman:make}:%
\footnote{Using \verb+cmp+ avoids touching the header file when its contents
haven't changed.
This trick is explained on pages 265--266 of Reference~\refno{kernighan:unix}.}
\begin{verbatim}
foo.c: foo.nw
        notangle -L foo.nw > foo.c
foo.h: foo.nw
        notangle -Rheader foo.nw > xfoo.h
        -cmp -s xfoo.h foo.h || cp xfoo.h foo.h
\end{verbatim}
I have used {\tt noweb}'s one-to-many mapping to combine several Modula-3 interfaces and
modules that
gradually reveal the definition of a partially opaque
type~\cite[Chapter~6]{nelson:systems}. 
A more interesting example is using {\tt noweb} to
interleave different languages in one source file. 
I wrote an \verb+awk+
script that read a machine description and emitted a disassembler for
that machine, and I used {\tt noweb} to combine the script and description
in a single file, so I could place each part of the input next to the
code that processed that input. 
The processing steps were:
{\par\advance\hsize by 2in % avoid complaints about overfull box in verbatim
\begin{verbatim}
notangle opcodes.nw > opcodes.awk
notangle -R'opcode table' opcodes.nw | awk -f opcodes.awk > disassem.sml
\end{verbatim}
}

Many-to-one mapping of source to program can be used to obtain
effects similar to those of Ada or Modula-3 generics.
If one puts 
generic code in a specially named chunk in a \verb+noweb+
file, e.g.~\verb+generic_list.nw+, one can then
``instantiate'' the code by putting a reference to that chunk in a
different file, e.g.~\verb|uses_list.nw|.
The instantiation takes the form:
\begin{verbatim}
notangle uses_list.nw generic_list.nw > instantiated_code.c
\end{verbatim} 
{\tt noweb} has no parameter mechanism, so the ``generic'' code must
refer to a fixed set of symbols, and it cannot be checked for errors
except by compiling \verb+instantiated_code.c+.
These restrictions make {\tt noweb} a poor approximation to real
generics, but useful nevertheless.


\section{Representation of {\tt noweb} files}

The \verb+noweb+ syntax is easy to read, write, and edit, but it is
not easily manipulated by programs.
The \verb+noweb+ tools use a representation that is easily manipulated
by commonly used Unix tools like {\tt sed} and {\tt awk}~\cite{kernighan:unix};
 \verb+markup+ converts a \verb+noweb+ program
to this representation.
\verb+notangle+ is a Unix shell script that builds a
pipeline between \verb+markup+ and \verb+nt+, which reads
and expands definitions of code chunks.
\verb+noweave+ pipes the output of \verb+markup+ to a 40-line
\verb+sed+~script that inserts appropriate {\TeX} or {\LaTeX} formatting commands.

Having a format easily read by programs makes {\tt noweb} extensible;
one can manipulate literate programs using Unix shell scripts and
filters.
To be able to share programs with colleagues who don't enjoy literate
programming, I modified \verb+notangle+ by adding to its pipeline a
stage that
places each line of documentation in a comment and moves it to
the succeeding code chunk.  The resulting script transforms a literate
program into a traditional commented program, without loss of
information and with only a moderate penalty in readability.
A second simple tool finds all the roots in a {\tt noweb} file, making
it easy to find definitions where chunk names have been misspelled.

\section{Discussion}

I have used \verb+noweb+ for a number of small C~programs (including
\verb+noweb+ itself), for a code generator for 
the Standard ML of New Jersey compiler (written in Standard
ML)~\cite{appel:smlnj}, and 
for a multi-architecture debugger, written in Modula-3 with some C and
assembly language.
\verb+markup+ and \verb+nt+ are \verb+noweb+ programs written in~C;
they are about 1200~lines of source of which about 400~lines are
interleaved documentation.
The code generator required 2600 lines, of which 900 lines were
interleaved documentation.
The debugger required 11,000~lines, of which 1,400 were interleaved
documentation.
A colleague used \verb+noweb+ to write an experimental file
system in C++~\cite{staelin:high}; he wrote 27,000~lines, of which
4,400 were interleaved documentation. 

{\tt WEB} takes the monolithic approach to literate programming---it
does everything.
{\tt noweb}'s approach is to compose
simple tools that manipulate files in the {\tt noweb} format. 
Such tools might be used to provide features found in {\tt WEB} but
not in {\tt noweb}, including cross-referencing of chunks, automatic
index generation, macro processing, prettyprinting code, typesetting
comments using {\TeX}, and converting string literals to indices into a
``string pool.''
Of these tools only the first could be language-independent.
An interactive browser for {\tt noweb} files would provide the
environment described in Reference~\refno{brown:interactive} to
programmers using any mix of languages.

% 
% {\tt WEB} source that is edited is very different from the typeset
% version that can be read.
% The differences can be confusing.
% Because programs are edited more often than read, much of the benefit
% of having typeset documentation is lost.
% \verb+noweave+ solves part of this problem by presenting the code
% chunks exactly as written.
% This solution might be improved by using \verb+noweb+ with a
% formatting tool like \verb+notex+~\cite{lipton:notex}, which produces
% typeset documents from well-formatted ASCII text containing no
% additional markup. 

\verb+noweb+ can be obtained by 
% sending electronic mail to \verb+nr@princeton.edu+%
% or by 
anonymous {\tt ftp} from  {\tt
princeton.edu}, in file {\tt pub/noweb.shar.Z}.

\section{Acknowledgements}
Mark Weiser's invaluable encouragement provided the impetus for me to
write this paper, which I did while visiting the Computer
Science Laboratory of the Xerox Palo Alto Research Center.
The development of {\tt noweb} was supported by a Fannie and John Hertz
Foundation Fellowship.

\bibliographystyle{abbrv}
\bibliography{web,cs,ramsey,ml}

\end{document}
