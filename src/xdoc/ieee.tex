\documentstyle[11pt]{article}
\title{Literate programming tools need not be complex}
\author{Norman Ramsey\\Princeton University}
\setcounter{secnumdepth}{0}

\def\remark#1{\marginpar{\raggedright\hbadness=10000\footnotesize\it #1}}
% \def\remark#1{\relax}


\begin{document}

\maketitle

\section{Introduction}
When literate programming was
introduced, it was synonymous with {\tt WEB}, a tool
for writing literate Pascal programs~\cite{knuth:literate}.
The idea attracted attention; several examples of literate
programs were published, and a special forum was created to discuss literate
programming~\cite{bentley:lp1,bentley:lp2,gries:pearls,denning:announcing}.
{\tt WEB} was  adapted to programming languages other than
Pascal~\cite{thimbleby:cweb,guntermann:cweb,levy:cweb,sewell:mangle,ramsey:building}.
Nevertheless there were reasons to be dissatisfied with {\tt
WEB}~\cite{ramsey:literate}.
Some people reacted by giving up on {\tt WEB}, converting their literate
programs back to standard programs with
comments;\footnote{David P. Dobkin, private communication.}
others built their own systems for literate programming.
Literate programming became the province of those who could build
their own tools~\cite{cvw:assessment}.

Today it is difficult to explore the {\em idea} of literate programming
because the {\em tools} get in the way.
To make it easier, I designed a minimal literate programming system
around one idea: writing named chunks of code in any order, with
interleaved documentation. 
This idea is a ``least common denominator'' in all the literate
programming systems I know of;
programmers divide a program into chunks and choose a presentation order
that helps explain the program.
My system is extensible; those who think
other features are important can add tools.

\section{{\tt noweb}, a minimal literate programming system}
A {\tt noweb} file contains program source code interleaved with documentation.
When {\tt notangle} is given a {\tt noweb} file, it writes the program
 on standard output. 
When {\tt noweave} is given a {\tt noweb} file, it reads the {\tt
noweb} source and produces, on standard output, {\TeX} source for
typeset documentation.
Figure~\ref{transforms} shows how to use {\tt notangle} and {\tt
noweave} to produce code and documentation for a C~program contained
in the {\tt noweb} file {\tt foo.nw}.

\begin{figure}
\footnotesize
\setlength{\unitlength}{2pt}
\begin{picture}(170,80)(0,-40)
\tt
\put(20,12.5){\makebox(0,0)[l]{\ \tt notangle foo.nw > foo.c}}
\put(20,-12.5){\makebox(0,0)[l]{\ \tt noweave foo.nw > foo.tex}}

\put(0,-5){\framebox(30,10){foo.nw}}
\put(15,5){\vector(1,2){7.5}}
\put(10,20){\framebox(30,10){foo.c}}
\put(15,-5){\vector(1,-2){7.5}}
\put(10,-30){\framebox(30,10){foo.tex}}

\put(40,-25){\vector(1,0){35}}
\put(57.5,-23.5){\makebox(0,0)[b]{tex foo}}
\put(75,-30){\framebox(30,10){foo.dvi}}
\put(105,-25){\vector(1,0){35}}
\put(122.5,-23.5){\makebox(0,0)[b]{\strut \tt dvi \rm driver}}
                        % \shortstack{\strut dvi\\\strut \rm driver}}}
\put(140,-25){\makebox(0,0)[l]{\rm\strut \ Typeset documentation for
{\tt foo}}}

\put(40,25){\vector(1,0){35}}
\put(57.5,26.5){\makebox(0,0)[b]{cc -c foo.c}}
\put(75,20){\framebox(30,10){foo.o}}
\put(105,25){\vector(1,0){35}}
\put(122.5,26.5){\makebox(0,0)[b]{ld foo.c {\ldots}}}
\put(140,25){\makebox(0,0)[l]{\rm\strut \ Executable \tt a.out}}



\end{picture}

\caption{Using {\tt noweb} to build code and documentation}
\label{transforms}
\end{figure}

A {\tt noweb} file is a sequence of {\em chunks}, which may appear in any order.
A chunk may contain code or documentation.
Documentation chunks begin with a line that starts with an at sign ({\tt @})
followed by a space or newline.
They have no names.
Code chunks begin with
\begin{quote} 
\tt <<{\it chunk name}>>=
\end{quote} 
on a line by itself.
The double left angle bracket ({\tt <<}) must be in the first column.
Chunks are terminated by the beginning of another chunk, or by end of file.
If the first line in the file does not mark the beginning of a
chunk, it is assumed to be the first line of a documentation chunk.

Documentation chunks contain text that is ignored by {\tt notangle}
and copied verbatim (except for quoted code) to standard output by
{\tt noweave}.   
{\tt noweave} can work with {\LaTeX}, or it can insert a reference to
a {\tt TeX} macro package, supplied with {\tt noweb}, that defines
commands like \verb+\chapter+ and \verb+\section+.

Code chunks contain program source code and references to other code
chunks.  
Several code chunks may have the same name; {\tt notangle}
concatenates their definitions to produce a single chunk, just as
{\tt WEB}'s {\tt TANGLE} does~\cite{knuth:web}.
Code chunk definitions are like macro definitions;
{\tt notangle} extracts a program by expanding one chunk (by default
the chunk named \verb+<<*>>+).
The definition of that chunk contains references to other chunks,
which are themselves expanded, and so on.
{\tt notangle}'s output is readable; it derives
sensible indentations and line breaks from the indentations and line
breaks present in its input.

Code may be quoted within documentation chunks by placing double
square brackets around it ({\tt [[...]]}). 
These double square brackets are ignored by {\tt notangle,} but they
are used by {\tt noweave} to give code special typographic
treatment.

To use the double left or right angle % or square 
bracket in code or documentation,
not as part of a chunk name, an author must quote the double 
bracket by placing an at sign in front of it (e.g.~``{\tt @<<}'').

\medskip

The preceding description of {\tt noweb} is taken from the Unix {\tt
man} page. 
It is sufficient to enable users to get started, even though 
the documentation of command-line options has been omitted. 
{\tt noweb} has little syntax: definition and use of code chunks, marking of
documentation chunks, quoting of code, and quoting of brackets.



\section{Using {\tt noweb}}% experience with noweb?

The cost of experimenting with \verb+noweb+ is low; there isn't much
syntax and the manual fits on two pages.
Most programs can be converted to \verb+noweb+ programs by making the
first line \verb+<<*>>=+.
Although such a program isn't very literate, it can gradually be made
more literate, and it doesn't break the tools.
\verb+noweb+ is completely independent of the target programming
language, and
its formatter-dependent part is small.

The original {\tt TANGLE}, part of {\tt WEB}, produced a ``code
brick;'' it converted newlines to white space to fill each line with
tokens.
Later adaptations preserved newlines but still changed indentation.
Programmers who experimented with {\tt WEB} but didn't like it had to
edit laboriously by hand in order to recover a readable, compilable
program from their {\tt WEB} source.
\verb+noweb+ makes it easy to abandon an experiment, because 
\verb+notangle+'s output is readable.
By default, \verb+notangle+ preserves the indentation of expanded
chunks with respect to the chunks in which they appear, as shown in
Figure~\ref{indentation}. 
\verb+notangle+, unlike {\tt WEB}, can be used with languages like
Miranda, in which changing indentation can change the meaning of a
program.

\begin{figure}
\begin{center}
\noindent
\begin{minipage}[t]{2.5in}
\begin{quote}\tt\obeyspaces
<<*>>=\\
one <<two>> <<three>>\\
<<two>>=\\
first of two\\
second of two\\
third of two\\
<<three>>=\\
first of three\\
\mbox{}\ second of three\\
\mbox{}\ \ third of three
\end{quote}
\end{minipage}\hfil
\begin{minipage}[t]{2.5in}
\begin{quote}\tt\obeyspaces
one\ first\ of\ two\\
\mbox{}\ \ \ \ second\ of\ two\\
\mbox{}\ \ \ \ third\ of\ \rlap{two\ first\ of\ three}\\
\mbox{}\rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ second\ of\ three}\\
\mbox{}\rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ \ third\ of\ three}
\end{quote}
\end{minipage}
\end{center}
\leavevmode\noindent
\hbox to \hsize{\hbox to 2.5in{\hss Input\hss}\hss\hbox to 2.5in{\hss Output\hss}}
\medskip
\begin{quote} 
Those who dislike literate programming can use {\tt notangle} once,
discard the original input, and work only with the output.
Preserving indentation makes the output readable.
It is also useful for programmers working in languages with no support
for preprocessors, or where newlines or indentation are significant.
\end{quote} 
\caption{{\tt notangle} preserving indentation}
\label{indentation}
\end{figure}

On a large project, it is essential that compilers and other tools be
able to refer to locations in the \verb+noweb+ source, even though
they work with \verb+notangle+'s output~\cite{ramsey:literate}.
Giving \verb+notangle+ the  \verb+-L+ option makes it emit pragmas
that inform compilers of the placement of lines
in the \verb+noweb+ source.
It also preserves the columns in which
tokens appear.
Figure~\ref{renumbering} shows an example using the line number
pragmas recognized by the C~preprocessor.
The empty line in the figure contains the blank that appeared on
line~2 between ``\verb+<<two>>+'' and ``\verb+<<three>>+.''

\begin{figure}
\begin{center}
\noindent
\begin{minipage}[t]{2.5in}
\begin{quote}\tt\obeyspaces
<<*>>=\\
one <<two>> <<three>>\\
<<two>>=\\
first of two\\
second of two\\
third of two\\
<<three>>=\\
first of three\\
\mbox{}\ second of three\\
\mbox{}\ \ third of three
\end{quote}
\end{minipage}\hfil
\begin{minipage}[t]{2.5in}
\begin{quote}\tt
\#line 2 "test.nw"\\
one\\
\#line 4 "test.nw"\\
first of two\\
second of two\\
third of two\\
\#line 2 "test.nw"\\
\mbox{\hskip 1em}\\
\#line 8 "test.nw"\\
first of three\\
\mbox{}\ second of three\\
\mbox{}\ \ third of three
\end{quote}
\end{minipage}
\end{center}
\leavevmode\noindent
\hbox to \hsize{\hbox to 2.5in{\hss Input\hss}\hss\hbox to 2.5in{\hss Output\hss}}
\begin{quote} 
Those who like literate programming can keep (and edit) the original
source, giving {\tt notangle}'s output to their compilers.
Preserving position information makes compiler messages refer to
locations in the original source.
\end{quote} 
\caption{{\tt notangle} preserving position information}
\label{renumbering}
\end{figure}


The mapping of \verb+noweb+ files to programs is many to many; the
mapping of files to documents is many to one.
Source files are combined by listing their names on \verb+notangle+'s
or \verb+noweave+'s command line.
Different programs are extracted by specifying the name
of the root chunk using \verb+notangle+'s \verb+-R+ command-line
option.

\clearpage % fixes bad break
The simplest example of a one-to-many mapping is that of putting
C~header and source in a single {\tt noweb} file.
Here rules for Make~\cite{feldman:make} that automate the
procedure:%
\footnote{Using \verb+cmp+ avoids touching the header file when its contents
haven't changed.
This trick is explained on pages 265--266 of Reference~\cite{kernighan:unix}.}
\begin{verbatim}
.SUFFIXES: .nw .h
.nw.c: ;        $(NOTANGLE) -L $*.nw >$*.c
.nw.h: ;        $(NOTANGLE) -Rheader $*.nw >x$*.h
                -cmp -s x$*.h $*.h || cp x$*.h $*.h
\end{verbatim}
Similarly,
I have used {\tt noweb} to combine several Modula-3 interfaces and
modules that
gradually reveal the definition of a partially opaque
type~\cite[Chapter~6]{nelson:systems}. 
An more interesting example is using {\tt noweb} to
interleave different languages in one source file. 
I wrote an \verb+awk+
script that read a machine description and emitted a disassembler for
that machine, and I used {\tt noweb} to combine the script and description
in a single file, so I could place each part of the input next to the
code that processed that input. 
The processing steps were:
{\par\advance\hsize by 2in % avoid complaints about overfull box in verbatim
\begin{verbatim}
notangle opcodes.nw > opcodes.awk
notangle -R'opcode table' opcodes.nw | awk -f opcodes.awk > disassem.sml
\end{verbatim}
}

Many-to-one mapping of source to program can be used to obtain
effects similar to those of Ada or Modula-3 generics.
Put 
generic code in a specially named chunk in a \verb+noweb+
file, e.g.~\verb+generic_list.nw+.
``Instantiate'' the code by putting a reference to that chunk in a
different file, e.g.~\verb|uses_list.nw|.
The instantiation takes the form:
\begin{verbatim}
notangle uses_list.nw generic_list.nw > instantiated_code.c
\end{verbatim} 
{\tt noweb} has no parameter mechanism, so the ``generic'' code must
refer to a fixed set of symbols, and it cannot be checked for errors
except by compiling \verb+instantiated_code.c+.
These restrictions make {\tt noweb} a poor approximation to real
generics, but useful nevertheless.


\section{{\tt noweb}'s architecture}

The \verb+noweb+ syntax is easy to read, write, and edit, but it is
not convenient for programs.
The \verb+noweb+ tools use a representation that is easier for
programs to manipulate; \verb+markup+ converts a \verb+noweb+ program
to this representation.
\verb+notangle+ is implemented as a Unix shell script that builds a
pipeline between \verb+markup+ and the program \verb+nt+, which does
the work.
\verb+noweave+ pipes the output of \verb+markup+ to a 40-line
\verb+sed+~script that inserts appropriate {\TeX} or {\LaTeX} formatting commands.

Having a format easily read by programs makes {\tt noweb} extensible;
one can write simple tools using Unix shell scripts and
filters~\cite{kernighan:unix}. 
To be able to share programs with friends who don't enjoy literate
programming, I modified \verb+notangle+ by adding to its pipeline a
stage that
places each line of documentation in a comment and moves it to
the succeeding code chunk.  The resulting script transforms a literate
program into a traditional commented program, without loss of
information and with only a moderate penalty in readability.
A second simple tool finds all the roots in a {\tt noweb} file, making
it easy to find definitions where chunk names have been misspelled.

\section{Experience and future work}

I have used \verb+noweb+ for a number of small C~programs (including
\verb+noweb+ itself), for a code generator for 
the Standard ML of New Jersey compiler (written in Standard ML), and
for a multiarchitecture debugger, written in Modula-3 with some C and
assembly language.
\verb+markup+ and \verb+nt+ are \verb+noweb+ programs written in~C;
they require about 1200~lines of source of which about 400~lines are
interleaved documentation.
The code generator required 2600 lines, of which 900 lines were
interleaved documentation.
The debugger required 11,000~lines, of which 1,400 were interleaved
documentation.
A colleague used \verb+noweb+ to write an experimental file
system in C++~\cite{staelin:high}; he wrote 27,000~lines, of which
4,400 were interleaved documentation. 

{\tt WEB} takes the monolithic approach to literate programming---it
does everything.
{\tt noweb}'s approach is to compose
simple tools that manipulate files in the {\tt noweb} format. 
In addition to {\tt notangle}, {\tt noweave}, and the other tools I
have written,
such tools might include:
\begin{itemize}
\item
A cross-reference generator for chunks.
\item
An interactive browser, like that of
Reference~\cite{brown:interactive}. 
\end{itemize}
Some tools need to know something about the target programming
language, perhaps its lexical or grammatical structure.
Such tools might include:
\begin{itemize}
\item
A prettyprinter.
\item
A tool that, like {\tt WEB}, generates an index of identifiers.
\item
A macro processor, like that of Reference~\cite{kernighan:m4}.
\item
A ``string pool'' tool, like \verb+xstr+~\cite{unix:xstr} or that of {\tt
WEB}. 
\end{itemize}


{\tt WEB} source that is edited is very different from the typeset
version that can be read.
The differences can be confusing.
Because programs are edited more often than read, much of the benefit
of having typeset documentation is lost.
\verb+noweave+ solves part of this problem by presenting the code
chunks exactly as written.
This solution might be improved by using \verb+noweb+ with a
formatting tool like \verb+notex+~\cite{lipton:notex}, which produces
typeset documents from well-formatted ASCII text containing no
additional markup. 

{\tt noweb} simplifies literate programming by using the Unix idea of
getting complex function by composing simple tools.
It keeps things simple for both authors and tool writers by using two
representations of literate programs: one that is simple for users to
read and edit, and one that 
is simple for programs to read and transform.
\verb+noweb+ can be obtained by 
sending electronic mail to \verb+nr@princeton.edu+%
% or by anonymous {\tt ftp} from Internet host {\tt
% princeton.edu:pub/noweb.shar.Z}
.
I hope its simplicity and availability will enable new
experiments with literate programming.

\section{Acknowledgements}
Mark Weiser's invaluable encouragment provided the impetus for me to
write this paper, which I did while visiting the Computer
Science Laboratory of the Xerox Palo Alto Research Center.
The development of {\tt noweb} was supported by a Fannie and John Hertz
Foundation Fellowship.

\bibliographystyle{unsrt}
\bibliography{web,cs,ramsey}

\def\semifilbreak{\vskip 0pt plus 1fil\penalty-200\vskip 0pt plus -1fil}

\semifilbreak
\section{A more complex example}

\def\caption#1{\centerline{#1}}

%\begin{figure}
\begin{quote}\tt\obeyspaces\rightskip=-1.5in
<<*>>=\\
switch(state)\ \{\\
\mbox{ }\ \ \ case\ Code:\ <<convert\ a\ code\ line>>\ break;\\
\mbox{ }\ \ \ case\ Docs:\ <<convert\ a\ documentation\ line>>\ break;\\
\mbox{ }\ \ \ default:\ impossible("bad\ state");\\
\}\\
@\ Converting\ a\ line\ of\ code\ requires\ separating\ it\ into\ \\
plain\ text\ and\ references\ to\ other\ chunks\ (``uses'').\\
<<convert\ a\ code\ line>>=\\
while\ (mark\ =\ use\_start(line,1))\ \{\ \\
\mbox{ }\ \ \ /*\ extract\ and\ print\ text,\ use\ */\\
\}\\
/*\ print\ text\ */\\
<<convert\ a\ documentation\ line>>=\\
/*\ code\ omitted\ for\ brevity\ */
\end{quote} 
\caption{Original {\tt noweb} source}
%\end{figure}

\semifilbreak

%\begin{figure}
\begin{quote}\tt\obeyspaces
switch(state)\ \{\\
\mbox{ }\ \ \ case\ Code:\ while\ (mark\ =\ use\_start(line,1))\ \{\ \\
\mbox{ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /*\ extract\ and\ print\ text,\ use\
 */\\
\mbox{ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\\
\mbox{ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ /*\ print\ text\ */\ break;\\
\mbox{ }\ \ \ case\ Docs:\ /*\ code\ omitted\ for\ brevity\ */\ break;\\
\mbox{ }\ \ \ default:\ impossible("bad\ state");\\
\}
\end{quote} 
\caption{{\tt notangle} output with indentation preserved}
%\end{figure}

\semifilbreak

%\begin{figure}
\begin{quote}\tt\obeyspaces
\#line\ 2\ "foo.nw"\\
switch(state)\ \{\\
\mbox{ }\ \ \ case\ Code:\ \\
\#line\ 10\ "foo.nw"\\
while\ (mark\ =\ use\_start(line,1))\ \{\ \\
\mbox{ }\ \ \ /*\ extract\ and\ print\ text,\ use\ */\\
\}\\
/*\ print\ text\ */\\
\#line\ 3\ "foo.nw"\\
\mbox{ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;}\\
\mbox{ }\ \ \ case\ Docs:\ \\
\#line\ 15\ "foo.nw"\\
/*\ code\ omitted\ for\ brevity\ */\\
\#line\ 4\ "foo.nw"\\
\mbox{ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rlap{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;}\\
\mbox{ }\ \ \ default:\ impossible("bad\ state");\\
\}
\end{quote} 
\caption{{\tt notangle} output with source position information preserved}
%\end{figure}


\end{document}
