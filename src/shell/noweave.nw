\section{Weaving a {\tt noweb} file into a \TeX file}
The copyright applies both to the {\tt noweb} source and to the
generated shell script.
<<copyright notice>>=
# Copyright 1991 by Norman Ramsey.  All rights reserved.
# See file COPYRIGHT for more information.
@
Here's the organization of the source:
<<noweave>>=
#!/bin/sh
<<copyright notice>>
<<initialization>>
<<scan options and arguments>>
<<emit markup on standard output>> |
$LIB/totex $delay
exit $?
@
The first item of initialization is to locate the {\tt noweb} library.
<<initialization>>= 
LIB=|LIBDIR|
@
<<initialization>>=
wrapper= delay= args= markopts= noweboptions= autodefs=
filtera= filterb= filterc= filterd=
@
I make two passes over the arguments so as not to require that options
be given in a certain order
<<scan options and arguments>>=
pass2args="$*"
while [ $# -gt 0 ]; do
  case $1 in
    <<first pass {\tt noweave} options>>
    -*) echo "$0: Unrecognized option '$1'" 1>&2 ; <<show usage>>; exit 1 ;;
    *)  arg="$arg $1" ;;
  esac
  shift
done
if [ -z "$wrapper" ]; then wrapper=latex; fi
if [ -n "$pass2args" ]; then
  set ignoreme $pass2args
  shift
  while [ $# -gt 0 ]; do
    case $1 in
      <<second pass {\tt noweave} options>>
    esac
    shift
  done
fi
<<add [[$newopt]] to [[noweboptions]]>>=
if [ -z "$noweboptions" ] ; then noweboptions="$newopt"
else noweboptions="$noweboptions,$newopt"
fi
<<first pass {\tt noweave} options>>=
-latex) wrapper=latex ;;
-tex)   wrapper=tex ;;
-n)     wrapper=none ;;
@
Note some versions of echo break on [[echo "-n..."]], echoing nothing 
at all.  The leading space is claimed to prevent this problem.
<<option printout for usage>>=
echo "-latex		Use LaTeX headers and trailers (default)." 1>&2
echo "-tex		Use TeX headers and trailers." 1>&2
echo " -n		Don't use any header or trailer." 1>&2
@ \iffalse
<<noweave man page option table>>=
.TP
.B \-latex
Use LaTeX wrapper in 
.B article
style with
.B noweb
style option and page style. (Default)
.TP 
.B \-tex
Use plain TeX wrapper and the
.B nwmac
macros.
.TP
.B \-n
Don't use any wrapper (header or trailer).
This option is useful when \fInoweave\fP's output will be
a part of a larger document.
See also 
.B \-delay.
@ \fi
<<first pass {\tt noweave} options>>=
-filter)    shift                                               ;;
-x|-index)         if [ -z "$wrapper" ]; then wrapper=latex; fi ;;
-indexfrom) shift; if [ -z "$wrapper" ]; then wrapper=latex; fi ;;
<<second pass {\tt noweave} options>>=
-filter) newfilter="$2" ; shift ;             <<add [[$newfilter]] (could overflow)>> ;;
-x)      newfilter="$LIB/noidx -noindex $delay"
                                              <<add [[$newfilter]] (could overflow)>> ;;
-index)  newfilter="$LIB/finduses -noquote" ; <<add [[$newfilter]] (could overflow)>>
         newfilter="$LIB/noidx $delay"      ; <<add [[$newfilter]] (could overflow)>> ;;
-indexfrom)
         newfilter="$LIB/finduses -noquote $2" ; <<add [[$newfilter]] (could overflow)>>
         newfilter="$LIB/noidx $delay"         ; <<add [[$newfilter]] (could overflow)>>
         shift ;;
<<option printout for usage>>=
echo "-x		Use the default cross-referencer (needs LaTeX)." 1>&2
echo "-index		Create index using identifiers defined in input files." 1>&2
echo "-indexfrom idx	Create index of identifers listed in file defs." 1>&2
echo "-filter cmd	Filter through 'cmd' before weaving; cmd could prettyprint" 1>&2
echo "			or perform other functions." 1>&2
@ \iffalse
<<noweave man page indexing options>>=
.TP
.B \-x
Add a page number to each chunk name identifying the location of that
chunk's definition, and emit cross-reference information relating definitions and uses.
Requires
.I LaTeX.
When
.B noweave -x
is used, the 
.I LaTeX
control sequence
.B "\\\\nowebchunks"
expands to a sorted list of all code chunks.
.TP
.B \-index
Build cross-reference information for identifiers defined by
.br
.B "@ %def" 
.I identifiers
.br
Definitions are those found in input files.
Requires
.I LaTeX.
.B \-index
and implies
.B \-x;
including both will generate strange-looking output.
.I noweave
does not generate
cross-references to identifiers that appear in quoted code (\fB@[[\fP...\fB@]]\fP).
When
.B noweave -index
is used, the 
.I LaTeX
control sequence
.B "\\\\nowebindex"
expands to an index of identifiers.
.TP
.B \-indexfrom \fIindex\fP
Like 
.B \-index,
but the identifiers to be indexed are taken from file \fIindex\fP.
See
.I noindex(1).
<<noweave man page option table>>=
.TP
.B \-filter \fIcmd\fP
Filters the 
.I noweb
source through 
.I cmd
after converting it to tool form and before converting to
.I TeX.
.I noweave
looks for 
.I cmd
first on the user's
.B PATH,
then in
.B |LIBDIR|.
Such filters
can be used to add features to
.I noweave;
for an example, see
.B |LIBDIR|/noxref.krom.
.I Noweave
supports up to four filters; one can get more by shell trickery, 
for example, \fB-filter "icon.filter | noidx"\fP.
The \fB-autodefs\fP,
\fB-x\fP, \fB-index\fP, and \fB-indexfrom\fP options are implemented as filters.
@ \fi 
Note that it would be appropriate to look for filters using [[[ -x $newfilter ]]],
but that stupid DEC Ultrix doesn't support [[test -x]], so the best I can
do in a portable way is [[test -r]].
<<first pass {\tt noweave} options>>=
-autodefs) newfilter="$LIB/autodefs.$2"
           if [ -r $newfilter ]; then <<add [[$newfilter]] (could overflow)>>
           else echo "$0: don't know how to find definitions for '$2'" 1>&2; exit 1
           fi
	   shift
           if [ -z "$wrapper" ]; then wrapper=latex; fi ;;
-showautodefs) <<print all legal [[-autodefs]] or complain>>; exit 1 ;;
<<option printout for usage>>=
echo "-autodefs lang	Source is in language 'lang'; find definitions automatically." 1>&2
echo "-showautodefs	List languages that can be used with -autodefs" 1>&2
@ \iffalse
<<noweave man page indexing options>>=
.TP
.B \-autodefs \fIlang\fP
Discover identifier definitions automatically.
Code in chunks must be in language \fIlang\fP.
Permissible \fIlang\fPs vary but may include
.B tex
or 
.B icon.
Useless without
.B \-index,
which it must precede.
.TP
.B \-showautodefs
Show values of \fIlang\fP usable with \fB-autodefs\fP.
@ \fi 
Same note as above regarding [[test -x]] vs [[test -r]].
<<print all legal [[-autodefs]] or complain>>=
foundautodefs=
for i in $LIB/autodefs.*; do
  if [ -r $i ]; then
    echo "This `basename $0` supports -autodefs $i" | 
                        sed "s@$LIB/autodefs\.@@" 1>&2
    foundautodefs=$i
  fi
done
if [ -z "$foundautodefs" ]; then
  echo "This `basename $0` does not support -autodefs"
fi
@
<<first pass {\tt noweave} options>>=
-option) newopt="$2"; shift; <<add [[$newopt]] to [[noweboptions]]>> ;;
<<option printout for usage>>=
echo "-option opt	Add \noweboptions{opt} to header (latex only)" 1>&2
@ \iffalse
<<noweave man page option table>>=
.TP 
.B \-option \fIopt\fP
Adds \fB\enoweboptions{\fP\fIopt\fP\fB}\fP to the
.I LaTeX
header.
Works only with the
.B \-latex
option.
See 
.I nowebstyle(1) 
for values of
.I opt.
@ \fi
<<first pass {\tt noweave} options>>=
# -nodelay) delay= ;;
-delay)   delay="-delay" ; wrapper=none ;;
<<option printout for usage>>=
echo "-delay		Delay markup until after first documentation chunk." 1>&2
@ \iffalse
<<noweave man page option table>>=
.TP
.B \-delay
By default, 
.I noweave
puts file-name and other information into the output before the first chunk
of the program.
.B \-delay
delays that information until after the first documentation chunk, making
act a little bit like the 
.I WEB
``limbo.''
The option is typically used to enable a user to put a specialized
.I LaTeX
.B "\\\\documentstyle"
command and other preamble material in the first documentation chunk.
This option also forces trailing cross-referencing information to be emitted
just before the final chunk, instead of at the end of the document;
the final chunk is expected to contain
.B "\\\\end{document}."
The 
.B \-delay
option implies the
.B \-n 
option.
@ \fi
% .TP
% .B \-nodelay
% Don't delay, put file-name and other information right after header. (Default)
% @ \fi
<<first pass {\tt noweave} options>>=
-t*) markopts="$markopts $1" ;;
<<option printout for usage>>=
echo "-tk		Expand tab stops every k columns" 1>&2
echo "-t		Copy tabs to the output" 1>&2
@ \iffalse
<<noweave man page option table>>=
.TP
.B \-t\fIk\fP
Expand tabs with stops every \fIk\fP columns.
(Default is to expand every 8 columns.)
.TP
.B \-t
Copy tabs to the output.
@ \fi
\iffalse
<<man page: WEAVING section>>=
Output from \fInoweave\fP can
be used in \fITeX\fP documents that 
.B "\\\\input nwmac"
and in  \fILaTeX\fP documents that  use the
.B noweb
document-style option (see\fInowebstyle(1)\fP).
.I Noweave
treats code chunks somewhat like
.I LaTeX list environments.
If the ``\fB@ \fP'' that terminates a code chunk is followed immediately by text,
that text follows the code chunk without a paragraph break.
If the rest of the line is blank, 
.I noweave
puts 
.I TeX
into ``vertical mode,'' and later text starts a fresh, indented paragraph.
.PP
No page breaks occur in the middle of code chunks unless necessary to avoid
an overfull vbox.
The documentation chunk immediately preceding a code chunk appears on
the same page as that code chunk unless doing so would violate the previous rule.
.PP
.I Noweave
inserts no extra newlines in its output, so the line numbers given
in
.I TeX
error messages are the same as those in the input file.
.PP
.I noweave
has
options that dictate choice of 
.I TeX
or 
.I LaTeX
and that support different formatting idioms and tools.
Basic options are described here; options related to index
and cross-reference information are described in the 
INDEXING AND CROSS-REFERENCE section.
<<noweave man page option table>>
@
<<man page: INDEXING AND CROSS-REFERENCE section>>=

@ \fi
<<add [[$newfilter]] (could overflow)>>=
if   [ -z "$filtera" ]; then
  filtera="$newfilter"
elif [ -z "$filterb" ]; then
  filterb="$newfilter"
elif [ -z "$filterc" ]; then
  filterc="$newfilter"
elif [ -z "$filterd" ]; then
  filterd="$newfilter"
else
  echo "$0: ran out of filters" 1>&2
  exit 1
fi
<<show usage>>=
echo "Usage: $0 [options] [files]" 1>&2
echo "Options recogized are:" 1>&2
<<option printout for usage>>
@
To avoid inserting any extra newlines into the output, 
I use [[@literal]]to insert headers and trailers.
The altered [[PATH]] provides a convenience to people who want to
use simple names to refer to filters in [[$LIB]].
<<emit markup on standard output>>=
(
<<write header literals>>
PATH="$PATH:$LIB" 
export PATH
if   [ -z "$filtera" ]; then
  $LIB/markup $markopts $arg
elif [ -z "$filterb" ]; then
  $LIB/markup $markopts $arg | $filtera
elif [ -z "$filterc" ]; then
  $LIB/markup $markopts $arg | $filtera | $filterb
elif [ -z "$filterd" ]; then
  $LIB/markup $markopts $arg | $filtera | $filterb | $filterc
else
  $LIB/markup $markopts $arg | $filtera | $filterb | $filterc | $filterd
fi
<<write trailer literals>>
)
@ \subsection{The header and trailer mess}
Shell implementations don't agree on backslash conventions, so I resort to the 
laborious method of using [[cat @<<EOF]]. 
It makes a royal mess of the code compared to using [[echo '\mumble']],
but it's portable.
The stuff has to appear in the first column or it won't work.
<<write header literals>>=
case "$wrapper" in
  tex)   
<<write literal saying [[\input nwmac]]>> ;;
  latex) 
<<write literal {\LaTeX} preamble>> ;;
esac
<<write trailer literals>>=
case "$wrapper" in
  tex)   
<<write literal saying [[\bye]]>> ;;
  latex) 
<<write literal saying [[\end{document}]]>> ;;
esac
@
I include extra trailing newlines to ensure
that [[EOF]] appears on a line by itself.
<<write literal saying [[\input nwmac]]>>=
cat <<EOF
@literal \input nwmac 
EOF

@
<<write literal {\LaTeX} preamble>>=
cat <<EOF
@literal \documentstyle[noweb]{article}\pagestyle{noweb}\noweboptions{$noweboptions}
@literal \begin{document}
EOF

<<write literal saying [[\bye]]>>=
cat <<EOF
@literal \bye
@nl
EOF

<<write literal saying [[\end{document}]]>>=
cat <<EOF
@literal \end{document}
@nl
EOF
  
@
